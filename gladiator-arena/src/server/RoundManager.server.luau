-- å›åˆæ§åˆ¶ + ä¸–ç•Œæ­å»º + ç®€æ˜“è¿‘æˆ˜æ­¦å™¨ + æœåŠ¡å™¨ä¾§ä¼¤å®³ä¸å†·å´
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local PhysicsService = game:GetService("PhysicsService")

-- ====== é…ç½® ======
local PREP_TIME   = 10   -- â³å‡†å¤‡é˜¶æ®µï¼ˆå…³ç¬¼å­ï¼‰
local COMBAT_TIME = 60   -- âš”ï¸æˆ˜æ–—é˜¶æ®µ
local RESET_TIME  = 6    -- ğŸ”„ç»“ç®—é˜¶æ®µ
local ATTACK_COOLDOWN = 0.7
local ATTACK_RANGE = 7
local ATTACK_DAMAGE = 25

local RoundTimerEvent = ReplicatedStorage:WaitForChild("RoundTimer")
local SwordAttackEvent = ReplicatedStorage:WaitForChild("SwordAttack")
local inRoundAttr = "InRound"
local Phase = "WAITING" -- WAITING / COMBAT / RESET

-- ====== ä¸–ç•Œç”Ÿæˆï¼šå¦‚æœä½ æ²¡æ‰‹æ‘†ï¼Œæˆ‘å¸®ä½ é€ ä¸ªæœ€å°ç¬¼å­+ç«æŠ€åœº ======
local function ensureWorld()
	print("å¼€å§‹ç”Ÿæˆä¸–ç•Œ...")
	
	-- æ¸…ç†æ—§çš„ä¸–ç•Œï¼ˆå¦‚æœå­˜åœ¨ï¼‰
	local oldArena = workspace:FindFirstChild("GeneratedArena")
	if oldArena then
		print("æ¸…ç†æ—§çš„ä¸–ç•Œ...")
		oldArena:Destroy()
	end
	
	local oldGates = workspace:FindFirstChild("Gates")
	if oldGates then
		oldGates:Destroy()
	end
	
	local oldSpawns = workspace:FindFirstChild("Spawns")
	if oldSpawns then
		oldSpawns:Destroy()
	end
	
	local model = Instance.new("Model")
	model.Name = "GeneratedArena"
	model.Parent = workspace
	print("åˆ›å»º GeneratedArena æ¨¡å‹")

	local function mkPart(props)
		local p = Instance.new("Part")
		p.Anchored = true
		p.CanCollide = true
		p.TopSurface = Enum.SurfaceType.Smooth
		p.BottomSurface = Enum.SurfaceType.Smooth
		for k, v in pairs(props) do p[k] = v end
		p.Parent = model
		return p
	end

	-- Cage: å·¦ä¾§ (-80, 0.5, 0)ï¼Œ40x40ï¼Œå¢™é«˜20ï¼Œä¸œä¾§ç•™é—¨
	print("ç”Ÿæˆç¬¼å­...")
	mkPart({Name="CageFloor", Size=Vector3.new(40,1,40), Position=Vector3.new(-80,0.5,0), Material=Enum.Material.Concrete, Color=Color3.fromRGB(200,200,200)})
	mkPart({Name="CageWall_N", Size=Vector3.new(40,20,1), Position=Vector3.new(-80,10.5,-20)})
	mkPart({Name="CageWall_S", Size=Vector3.new(40,20,1), Position=Vector3.new(-80,10.5,20)})
	mkPart({Name="CageWall_W", Size=Vector3.new(1,20,40), Position=Vector3.new(-100,10.5,0)})
	-- ä¸œå¢™æ‹†æˆä¸¤æˆªç•™ 6 å®½é—¨
	mkPart({Name="CageWall_E_L", Size=Vector3.new(1,20,17), Position=Vector3.new(-60,10.5,-11.5)})
	mkPart({Name="CageWall_E_R", Size=Vector3.new(1,20,17), Position=Vector3.new(-60,10.5, 11.5)})
	
	-- é—¨ï¼šé»˜è®¤å…³ï¼ˆå¯ç¢°æ’ï¼‰
	local gatesFolder = Instance.new("Folder")
	gatesFolder.Name = "Gates"
	gatesFolder.Parent = workspace
	local gate = mkPart({Name="CageGate", Size=Vector3.new(1,12,6), Position=Vector3.new(-60,6.5,0), Color=Color3.fromRGB(255, 170, 0)})
	gate.Parent = gatesFolder
	print("ç”Ÿæˆç¬¼é—¨")

	-- Arena: ä¸­é—´ (0, 0.5, 0)ï¼Œ120x120
	print("ç”Ÿæˆç«æŠ€åœº...")
	mkPart({Name="ArenaFloor", Size=Vector3.new(120,1,120), Position=Vector3.new(0,0.5,0), Material=Enum.Material.Concrete, Color=Color3.fromRGB(170,170,170)})
	mkPart({Name="ArenaWall_N", Size=Vector3.new(120,20,1), Position=Vector3.new(0,10.5,-60)})
	mkPart({Name="ArenaWall_S", Size=Vector3.new(120,20,1), Position=Vector3.new(0,10.5,60)})
	mkPart({Name="ArenaWall_W", Size=Vector3.new(1,20,120), Position=Vector3.new(-60,10.5,0)})
	mkPart({Name="ArenaWall_E", Size=Vector3.new(1,20,120), Position=Vector3.new(60,10.5,0)})

	-- Spawnsï¼ˆæ ‡è®°ç‚¹ï¼Œè„šæœ¬ä¼šè¯»å–åæ ‡ï¼‰
	local spawns = Instance.new("Folder"); spawns.Name="Spawns"; spawns.Parent = workspace
	local cageF = Instance.new("Folder"); cageF.Name="Cage"; cageF.Parent = spawns
	local arenaF = Instance.new("Folder"); arenaF.Name="Arena"; arenaF.Parent = spawns

	local function mkSpawn(name, pos, parent)
		local s = Instance.new("Part")
		s.Name = name
		s.Size = Vector3.new(2,1,2)
		s.Anchored = true
		s.CanCollide = false
		s.Transparency = 1
		s.Position = pos
		s.Parent = parent
		return s
	end
	mkSpawn("CageSpawn1", Vector3.new(-88, 6, -12), cageF)
	mkSpawn("CageSpawn2", Vector3.new(-88, 6,  12), cageF)
	mkSpawn("CageSpawn3", Vector3.new(-72, 6, -12), cageF)
	mkSpawn("CageSpawn4", Vector3.new(-72, 6,  12), cageF)

	mkSpawn("ArenaSpawn1", Vector3.new( -8, 6, -8), arenaF)
	mkSpawn("ArenaSpawn2", Vector3.new(  8, 6,  8), arenaF)
	mkSpawn("ArenaSpawn3", Vector3.new(-12, 6, 12), arenaF)
	mkSpawn("ArenaSpawn4", Vector3.new( 12, 6,-12), arenaF)
	print("ç”Ÿæˆå‡ºç”Ÿç‚¹")
	
	print("ä¸–ç•Œç”Ÿæˆå®Œæˆï¼")
end

local function setGates(open: boolean)
	local gates = workspace:FindFirstChild("Gates")
	if not gates then return end
	for _, g in ipairs(gates:GetChildren()) do
		if g:IsA("BasePart") then
			g.CanCollide = not open
			g.Transparency = open and 0.6 or 0
		end
	end
end

-- ====== å‡ºç”Ÿç‚¹è¯»å– ======
local function collectSpawnPositions(folder: Instance?): {Vector3}
	local list = {}
	if folder then
		for _, c in ipairs(folder:GetChildren()) do
			if c:IsA("BasePart") then table.insert(list, c.Position + Vector3.new(0, 3, 0)) end
		end
	end
	return list
end

local function getSpawnPositions()
	local spawns = workspace:FindFirstChild("Spawns")
	local cage = spawns and spawns:FindFirstChild("Cage")
	local arena = spawns and spawns:FindFirstChild("Arena")
	local cagePos = collectSpawnPositions(cage)
	local arenaPos = collectSpawnPositions(arena)
	if #cagePos == 0 then
		cagePos = {Vector3.new(-88,6,-12), Vector3.new(-88,6,12), Vector3.new(-72,6,-12), Vector3.new(-72,6,12)}
	end
	if #arenaPos == 0 then
		arenaPos = {Vector3.new(-8,6,-8), Vector3.new(8,6,8), Vector3.new(-12,6,12), Vector3.new(12,6,-12)}
	end
	return cagePos, arenaPos
end

local function rotateIndex(idx, n) return (idx % n) + 1 end

-- ====== å‘ç®€æ˜“æ­¦å™¨ï¼ˆä¸éœ€è¦ Tool å†…è„šæœ¬ï¼‰======
local function giveWeapon(p: Player)
	print("å°è¯•ç»™ç©å®¶", p.Name, "å‘æ”¾æ­¦å™¨")
	
	-- å¦‚ç©å®¶å·²æœ‰åˆ™ä¸é‡å¤å‘
	if p.Backpack:FindFirstChild("Gladius") or (p.Character and p.Character:FindFirstChild("Gladius")) then 
		print("ç©å®¶", p.Name, "å·²æœ‰æ­¦å™¨ï¼Œè·³è¿‡")
		return 
	end

	local tool = Instance.new("Tool")
	tool.Name = "Gladius"
	tool.RequiresHandle = true
	tool.CanBeDropped = false

	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(1,1,3)
	handle.Color = Color3.fromRGB(230, 230, 230)
	handle.Massless = true
	handle.CanCollide = false
	handle.Parent = tool

	tool.Parent = p.Backpack
	print("æˆåŠŸç»™ç©å®¶", p.Name, "å‘æ”¾æ­¦å™¨")
end

-- ====== æœåŠ¡å™¨ä¾§æ”»å‡»åˆ¤å®šï¼ˆé˜²ä½œå¼Šï¼šå†·å´ã€è·ç¦»ã€é˜¶æ®µï¼‰======
local lastSwingAt: {[number]: number} = {} -- userId -> timestamp

local function doMeleeDamage(attacker: Player)
	if Phase ~= "COMBAT" then return end
	if not attacker.Character then return end

	local now = os.clock()
	local last = lastSwingAt[attacker.UserId] or 0
	if now - last < ATTACK_COOLDOWN then return end

	local hrp = attacker.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- åœ†å½¢èŒƒå›´æ£€ç´¢
	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = { attacker.Character }

	local parts = workspace:GetPartBoundsInRadius(hrp.Position, ATTACK_RANGE, params)
	local hitHumanoids = {}
	for _, part in ipairs(parts) do
		local m = part:FindFirstAncestorOfClass("Model")
		if m and m ~= attacker.Character then
			local hum = m:FindFirstChildOfClass("Humanoid")
			if hum and hum.Health > 0 then
				hitHumanoids[hum] = true
			end
		end
	end

	for hum, _ in pairs(hitHumanoids) do
		hum:TakeDamage(ATTACK_DAMAGE)
	end

	lastSwingAt[attacker.UserId] = now
end

SwordAttackEvent.OnServerEvent:Connect(function(p: Player, payload)
	if typeof(payload) ~= "table" or payload.action ~= "swing" then return end
	-- åªæœ‰æŒæœ‰æ­¦å™¨çš„å‚èµ›è€…æ‰èƒ½æ”»å‡»
	if not p:GetAttribute(inRoundAttr) then return end
	local has = (p.Backpack and p.Backpack:FindFirstChild("Gladius")) or (p.Character and p.Character:FindFirstChild("Gladius"))
	if not has then return end
	doMeleeDamage(p)
end)

-- ====== é˜¶æ®µå†…é€šç”¨ ======
local function broadcast(phase: string, secs: number)
	RoundTimerEvent:FireAllClients({ phase = phase, secs = secs })
end

local function resetPlayer(p: Player)
	-- æ¸…èƒŒåŒ…ä¸è¡€é‡
	if p.Backpack then for _, it in ipairs(p.Backpack:GetChildren()) do if it:IsA("Tool") then it:Destroy() end end end
	local char = p.Character
	if char then
		for _, it in ipairs(char:GetChildren()) do if it:IsA("Tool") then it:Destroy() end end
		local hum = char:FindFirstChildOfClass("Humanoid"); if hum then hum.Health = hum.MaxHealth end
	end
end

local function moveTo(p: Player, pos: Vector3)
	local char = p.Character or p.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart", 5)
	if hrp then char:MoveTo(pos) end
end

local function aliveCount()
	local n = 0
	local totalPlayers = 0
	for _, p in ipairs(Players:GetPlayers()) do
		totalPlayers += 1
		local inRound = p:GetAttribute(inRoundAttr)
		if inRound then
			local hum = p.Character and p.Character:FindFirstChildOfClass("Humanoid")
			if hum and hum.Health > 0 then 
				n += 1 
				print("ç©å®¶", p.Name, "å­˜æ´»ï¼Œè¡€é‡:", hum.Health)
			else
				print("ç©å®¶", p.Name, "æ­»äº¡æˆ–æ— è§’è‰²")
			end
		else
			print("ç©å®¶", p.Name, "ä¸åœ¨å›åˆä¸­")
		end
	end
	print("æ€»ç©å®¶æ•°:", totalPlayers, "å­˜æ´»ç©å®¶æ•°é‡:", n)
	return n
end

-- æ–°ç©å®¶/é‡ç”Ÿæ—¶æ”¾å¯¹ä½ç½®
local function placeAccordingToPhase(p: Player)
	local cagePos, arenaPos = getSpawnPositions()
	if Phase == "COMBAT" and p:GetAttribute(inRoundAttr) then
		moveTo(p, arenaPos[1])
	else
		moveTo(p, cagePos[1])
	end
end

Players.PlayerAdded:Connect(function(p)
	print("ç©å®¶åŠ å…¥:", p.Name)
	p:SetAttribute(inRoundAttr, false)
	p.CharacterAdded:Connect(function() 
		print("ç©å®¶è§’è‰²ç”Ÿæˆ:", p.Name)
		task.wait() 
		placeAccordingToPhase(p) 
	end)
end)

-- ====== ä¸»å¾ªç¯ ======
task.spawn(function()
	print("=== è§’æ–—å£«ç«æŠ€åœºå¯åŠ¨ ===")
	
	-- æ·»åŠ é”™è¯¯å¤„ç†
	local success, err = pcall(function()
		ensureWorld()
		print("ä¸–ç•Œå·²ç”Ÿæˆï¼Œå¼€å§‹æ¸¸æˆå¾ªç¯...")

		local cageIdx, arenaIdx = 1, 1
		while true do
			-- ç­‰å¾…è‡³å°‘ä¸€ä¸ªç©å®¶åŠ å…¥
			print("ç­‰å¾…ç©å®¶åŠ å…¥...")
			while #Players:GetPlayers() == 0 do
				task.wait(1)
			end
			print("æ£€æµ‹åˆ°ç©å®¶ï¼Œå¼€å§‹æ¸¸æˆå¾ªç¯")

			-- å‡†å¤‡ï¼šå…¨éƒ¨å‚èµ›ï¼Œæ‹‰è¿›ç¬¼å­ï¼Œå…³é—¨
			Phase = "WAITING"
			print("=== å‡†å¤‡é˜¶æ®µå¼€å§‹ ===")
			local cagePos, arenaPos = getSpawnPositions()
			print("å‡†å¤‡é˜¶æ®µï¼šå½“å‰ç©å®¶æ•°é‡:", #Players:GetPlayers())
			
			for _, p in ipairs(Players:GetPlayers()) do
				print("è®¾ç½®ç©å®¶", p.Name, "åŠ å…¥å›åˆ")
				p:SetAttribute(inRoundAttr, true)
				resetPlayer(p)
				moveTo(p, cagePos[cageIdx]); cageIdx = rotateIndex(cageIdx, #cagePos)
				print("ç©å®¶", p.Name, "åŠ å…¥å›åˆï¼Œå±æ€§è®¾ç½®ä¸º:", p:GetAttribute(inRoundAttr))
			end
			setGates(false)
			print("å¼€å§‹å‡†å¤‡é˜¶æ®µå€’è®¡æ—¶...")
			for t = PREP_TIME, 0, -1 do 
				broadcast("WAITING", t); 
				print("å‡†å¤‡å€’è®¡æ—¶:", t)
				task.wait(1) 
			end

			-- æˆ˜æ–—ï¼šå¼€é—¨ï¼Œä¼ åˆ°ç«æŠ€åœºå¹¶å‘æ­¦å™¨
			Phase = "COMBAT"
			print("=== æˆ˜æ–—é˜¶æ®µå¼€å§‹ ===")
			setGates(true)
			local cagePos2, arenaPos2 = getSpawnPositions()
			print("æˆ˜æ–—é˜¶æ®µï¼šæ£€æŸ¥ç©å®¶çŠ¶æ€...")
			
			for _, p in ipairs(Players:GetPlayers()) do
				local inRound = p:GetAttribute(inRoundAttr)
				print("æ£€æŸ¥ç©å®¶", p.Name, "å›åˆçŠ¶æ€:", inRound)
				
				if inRound then
					resetPlayer(p)
					moveTo(p, arenaPos2[arenaIdx]); arenaIdx = rotateIndex(arenaIdx, #arenaPos2)
					giveWeapon(p)
					print("ç»™ç©å®¶", p.Name, "å‘æ”¾æ­¦å™¨")
				else
					print("ç©å®¶", p.Name, "ä¸åœ¨å›åˆä¸­ï¼Œè·³è¿‡")
				end
			end
			
			print("å¼€å§‹æˆ˜æ–—å€’è®¡æ—¶...")
			for t = COMBAT_TIME, 0, -1 do
				broadcast("COMBAT", t)
				local alive = aliveCount()
				print("æˆ˜æ–—å€’è®¡æ—¶:", t, "å­˜æ´»:", alive)
				if alive <= 0 then 
					print("æˆ˜æ–—ç»“æŸï¼Œæ²¡æœ‰å­˜æ´»ç©å®¶")
					break 
				end
				task.wait(1)
			end

			-- ç»“ç®—ï¼šå…³é—¨ï¼Œå›ç¬¼å­ï¼Œæ¸…å‚èµ›æ ‡è®°
			Phase = "RESET"
			print("=== ç»“ç®—é˜¶æ®µå¼€å§‹ ===")
			setGates(false)
			local cagePos3 = select(1, getSpawnPositions())
			for _, p in ipairs(Players:GetPlayers()) do
				p:SetAttribute(inRoundAttr, false)
				resetPlayer(p)
				moveTo(p, cagePos3[cageIdx]); cageIdx = rotateIndex(cageIdx, #cagePos3)
			end
			print("å¼€å§‹ç»“ç®—é˜¶æ®µå€’è®¡æ—¶...")
			for t = RESET_TIME, 0, -1 do 
				broadcast("RESET", t); 
				print("ç»“ç®—å€’è®¡æ—¶:", t)
				task.wait(1) 
			end
		end
	end)
	
	if not success then
		print("ä¸»å¾ªç¯å‘ç”Ÿé”™è¯¯:", err)
		print("é”™è¯¯å †æ ˆ:", debug.traceback())
	end
end)
